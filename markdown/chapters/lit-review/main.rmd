\chapter{Visualisation Programming}

This chapter will discuss the programming behind the visualisations presented in the surveys, and present results of interviews discussing the opinions of programming specialists in relation to the codes. As previously discussed, two languages were used to create the plots; R and Python. Initially, the JavaScript D3 library was also considered, but discounted due to time constraints. The D3 library will, however, be briefly discussed here. The previous literature review discussed the overall theory behind the design of visualisation, but an additional review of literature regarding coding for visualisations will be undertaken here.


\section{A Review of Literature}

\subsection{Choosing the correct tool}
In @wilke2019, the author discusses how to choose the right visualisation software, exploring the areas of 'Reproducibility and Repeatability', 'Data exploration versus data presentation', and 'Separation of content and design'. 

He starts off by remarking that a person will tend to lean into producing visuals in their already preferred tools, and he mentions the 'strong emotional bond' one may have to their preferred tool. This is discussed as a not necessarily a negative concept, since the process of training to use a new tool can be time-consuming and mentally taxing, with the end thus results potentially not being as accomplished or polished as if the individual had spent the same time and effort creating the visual with the tool they know. 

This factor may be assessed on a case-by-case basis; if the preferred tool provides adequate results then this may be favoured as more time and energy can be put into creating the graphic itself as opposed to learning a new tool, however if another tool performs the given task remarkably better than the preferred, then it should be at least considered in the visual design process. This will be investigated in the interviews, as there is roughly a 50/50 split between respondents preferring R, and those favouring Python, and so it will be interesting to see if this impacts opinions on the tool used to create the visuals.

The author states that \textit{'The best visualization software is the one that allows you to make the figures you need'}, meaning that if the old tool allows a user to produce visuals better than leaning a new one, even though the new may be better suited, it would be preferable to choose whichever allows the needed figures to be created for the individual. However, he then goes on to explain the benefits of having the knowledge of many tools in an arsenal, as this can allow the user to make an informed decision on the best tool for the job, much like an engineer with a tool box. 

The definitions of 'reproducability' and 'repeatability' used by Wilke closely mirror those used in investigative science; 'reproducability' is the ability of the visualisation to be re-created by another user with access to the data, and 'repeatabiity' is the ability of the visualisation to be exactly replicated by the original creator. It is important to note here that Wilke remarks that a 'reproducible' visualisation does not need to be identical to the original in terms of aesthetics, but the content of the plot should be the same. Wilke does, however, state that the 'repeatable' graphics should be able to be identical every time they are created. 

\subsection{Interactive visualisation tools}
One conclusion Wilke draws is that less programmatic and more interactive tools, for example Tableau [@tableau] or Spotfire [@spotfire], may reduce the reproducibility of visualisations as a result of the live visualisation editing with more limited active change tracking. The lack of change tracking can lead the original creator of a visual to forget what alterations have been made between a start and finish product if a manual effort to track changes is not made, resulting in neither the original creator nor another individual being able to replicate or reproduce the visualisation easily. The author even states that he tries to \textit{'stay away from interactive programs as much as possible'}, as programmatic methods, for which data and scripts may be easily shared, lend themselves much more to reproduction and replication. 

There are benefits to interactive plotting tools, however, as discussed by @LUO2019113061. Such tools are beneficial for presenting data in a way that allows audience questions or queries regarding the data to be investigated and answered in real time, as opposed to programmatic methods, which are fairly fixed during presentation, with modifications involving altering and re-running the underlying code. Programmatic methods, in this way, can be more time consuming and less flexible.

A tool of an interactive nature allows the user to closely follow the aforementioned \textit{'Visual Information Seeking Mantra'}, as they are able to actively control the depth and complexity of information being presented, once again in real time. As well as for presentations, an interactive format is useful for data exploration, perhaps for discovering patterns and connections as a precursor to creating similar visuals using a programming tool. Interactive tools allow the user to filter, sort and really drill down into the data with a few clicks, as opposed to having to re-run many lines of code every time an alteration is made.

Whether to choose an interactive tool or not depends heavily on the goal of the visualisation, and the medium with which it is being presented. For example, static, programmatic visuals, would be ideal for a scientific research paper, but a pharmaceutical representative presenting study data to healthcare professionals may benefit from the abilities of an interactive tool. 

The JavaScript library d3.js [@d3] is an example of a tool that, while lacking in its ability to clean and manipulate data, can take advantage of both programmatic methods and interactivity.This is explained by @javapy, where the author also discusses how the programmatic nature of Python can be utilised in conjunction with the ability of JavaScript to create dynamic, browser-based visuals. In the book, it is explained how the early stages of data cleaning, manipulation and exploration can be done in Python, with the transformation into interactive visual information being undertaken by D3, as per figure \ref{toolchain}, presented in the book. This process is referred to as the 'dataviz toolchain'.

D3 may also be used alone to create visuals, however employing Python in the early stages allows for easier data handling and manipulation. Prior to employing D3, interactive Python interfaces such as \textit{IPython} can be used to explore the data with packages such as \textit{Seaborn} or \textit{Matplotlib}, allowing for cleaning and refinement of data for visualisation in D3.

D3 itself makes use of Cascading Style Sheets (CSS) and Scalar Vector Graphics (SVG) to make high quality visuals. The use of SVG is particularly beneficial as these graphics are able to be re-scaled to any dimension without becoming blurry or distorted, meaning they do not suffer from a loss of quality when being scaled. This is a strength of D3 for visualisation, in addition to the interactive and dynamic visuals.

![The Dataviz Toolchain \label{toolchain}](C:/Users/Katie/OneDrive/Uni_Work_Year4/project/Year-4-Project/markdown/chapters/Interviews/toolchain.jpg)

When it comes to static visuals, as investigated in this study, two commonly used tools as the \textit{ggplot2} package in R and the \textit{matplotlib} library in Python, which are investigated here. 

\section{Background on R and Python}
R and Python are two languages that differ in programming paradigms, with R being a mostly functional language and Python taking more of a multi-paradigm approach, incorporating mainly elements of object-oriented programming, but along with some elements of procedure-oriented and functional paradigms [@paradigm]. 

At a basic level, functional programming does exactly what the name says; it operates mainly using functions to obtain results and output, with the ability to use certain functions within others to create new functions that act as compositions of other functions.

Object-oriented programming, on the other hand, focuses on storing information in 'objects', with attributes as defined by their 'class'. Information in a class structure is then accessed in the format 'class.object'. In addition to objects, 'methods', or functions, can be assigned to and defined by a class.

These two differing methods of programming, like everything, have a series of positives and negatives. A positive shared by both R and Python is that they are open-source, unlike languages such as SAS or MATLAB, meaning anyone can gain access with no paywalls, and anyone can contribute to development of new packages and libraries, creating communities among people who develop in these languages and allowing creativity of people from all areas to be used in development. Both of these are also fairly good for creating visualisations in a reproducable and replicable way.

Some differences between the two languages are outlined by @rvpy. One main difference is R's main purpose of data exploration and statistical analysis, as compared to Python use in more general programming, but with applications in data wrangling. Both therefore can be used for data cleaning, analysis and visualisation, but R is more suited than Python to running in depth statistical testing and analysis, whereas Python is more suited than R to applications such as large-scale machine learning.

Python is regarded as a fairly easy to learn language and is known as one of the most popular languages worldwide, especially among programmers and developers. R appears to be noted as a generally slightly more difficult to learn language, but is a popular choice among statisticians and data scientists, particularly in R&D.

\subsection{Plotting libraries in R and Python}
In terms of visualisation, both R and Python contain a variety of packages and libraries for plotting of data.

\textit{ggplot2} is generally regarded as 

\textit{Matplotlib} takes elements from MATLAB, using them in python to 


The languages \textit{ggplot2} and \textit{matplotlib} will be further explored when discussing the interviews, below.



\section{Code based interviews}

\subection{Background on semi-structured interviews}
 A semi structured interview, as briefly discussed before
















